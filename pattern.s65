                .include "submodules/beeb/include/beeb.s65"
                .cpu '65c02'

;-------------------------------------------------------------------------

*=$70
                .dsection zp
*=$1900
                .dsection code

;-------------------------------------------------------------------------

                .section zp
addr:
                .fill 2
xc:
                .fill 1
yc:
                .fill 1
counter:
                .fill 1
pixel:
                .fill 1
                .endsection

;-------------------------------------------------------------------------

                .section code
                lda #22
                jsr oswrch
                lda #12         ;i.e., mode 4
                jsr oswrch

                sei
                stz $fe20

                sta $fe00
                lda #$28        ;$7c00
                sta $fe01
                lda #1
                sta $fe00
                ldy #32
                sty $fe01

                ; lda #acccon.d
                ; sta acccon

                clc
                dec a
                tay
set_palette_loop:
                sta $fe21
                adc #$11
                bcc set_palette_loop

                ; doesn't matter what the initial values of addr or
                ; counter are, though the writing will start at an
                ; arbitrary position on screen and the counter may or
                ; may not increment first time round...
fix_addr_msb:
                lda addr+1
                inc a
                bpl +
                
                inc counter

                pha
                
                ; hit top of screen - wait for vsync.
;                 lda #2
; wait_for_vsync_loop:
;                 bit system_via.ifr
;                 beq wait_for_vsync_loop
;                 sta system_via.ifr
                
                ; lda acccon
                ; eor #acccon.d|acccon.x
                ; sta acccon
                
                pla
+
                and #%00000011
                ora #$7c
                sta addr+1
loop:
                
                lda addr+1
                sta yc
                lda addr+0
                sta xc

                ldx #3
get_yc_loop:
                asl a
                rol yc
                dex
                bne get_yc_loop

                ; high nybble of addr?1 is always %0111.
                ; so C=1 at this point.

                lda xc
                clc
                adc counter     ;extra +1 irrelevant
                eor yc
                and #8
                lsr a
                lsr a
                lsr a
                sta pixel

                lsr xc
                lsr yc
                clc
                lda counter
                eor #$ff
                adc xc
                eor yc
                and #2
                ora pixel
                tax
                lda pixel_table,x
                
                sta (addr)

                inc addr+0
                beq fix_addr_msb
                bra loop

pixel_value: .function colour
right=(
                .endfunction 

pixel_table:
                .byte %00000000^$ff ;black
                .byte %00111111^$ff ;white
                .byte %00110000^$ff ;blue
                .byte %00111111^$ff ;white
                
                .endsection