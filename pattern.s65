                .include "submodules/beeb/include/beeb.s65"
                .cpu '65c02'

;-------------------------------------------------------------------------

*=$70
                .dsection zp
*=$1900
                .dsection code

;-------------------------------------------------------------------------

                .section zp
saddr:
                .fill 2
yc:
                .fill 1
counter:
                .fill 1
temp:
                .fill 1
                .endsection

;-------------------------------------------------------------------------

                .section code
start:
                ; best to start with counter set to 0, to ensure the
                ; first bit of music lasts for a decent amount of
                ; time.
                ;
                ; the initial value of saddr isn't so important.
                stz counter

                ldx #init_text_end-init_text_begin-1
init_loop:
                lda init_text_begin,x
                jsr oswrch
                dex
                bpl init_loop

                sei

                stx $fe43

                ; ; set some random frequency on tone 3
                ; ;
                ; ; (best to reuse tone 3, as it's the bootup beep)
                lda #$8f
                jsr sn_write
                lda #$3f
                jsr sn_write

fix_addr_msb:
                inc saddr+1
                bpl got_addr_msb

                jsr next_frame

got_addr_msb:
                lda saddr+1
                and #%00000011
                ora #$7c
                sta saddr+1

do_pixel:                
                lda saddr+1
                sta yc
                lda saddr+0

                ; saddr high nybble is always 7 (%0111)
                asl a
                rol yc          ;C=0
                asl a
                rol yc          ;C=1
                asl a
                rol yc          ;C=1

                lda counter
layer0:
                jsr type_codes+1*type_code_size
                and #4
                sta temp

                lda counter
                lsr a
                tax
                sec
layer1:
                jsr type_codes+2*type_code_size
                and #8
                ora temp
                lsr a
                sta temp

                txa
                lsr a
                sec
layer2:
                jsr type_codes+3*type_code_size
                and #8
                ora temp
                lsr a
                
pixel_mask=*+1
                and #0
                tay

                ; bit saddr+0
                ; bne write_pixel

                eor #$0f
call_music:
                jsr music1
                and #$0f
                eor #%10010000  ;tone 3 attenuation
                ;eor #%10011111  ;tone 3 attenuation, invert volume
                jsr sn_write

write_pixel:
                lda pixel_table,y
                sta (saddr)

next_byte:
                inc saddr+0
                beq fix_addr_msb

                bra do_pixel

next_frame:
                ; TODO - could use top 6 bits of address instead?

                lda acccon
                eor #acccon.d|acccon.x
                sta acccon
                                
                inc counter
                bne +
                ldx #$18        ;CLC
                stx next_sequence
+

update_music:
                ; lda counter
                ; bit #1
                ; bne update_sequence

next_music:
                lda call_music+1
                eor #<(music1^music2)
                sta call_music+1
                
update_sequence:
                lda counter
                bit #15
                bne done

next_sequence:
                sec
                rol pixel_mask

                ; next frame...
                ldx #layer0-start
                jsr change_layer

                ldx #layer1-start
                jsr change_layer

                ldx #layer2-start
change_layer:
                clc
                lda start+1,x   ;code LSB
                adc #type_code_size
                bcc got_layer_lsb     ;90 02
                lda #type_codes-start ;a9 e2
got_layer_lsb:
                sta start+1,x

music2:
done:
                rts             ;1

init_text_begin=*-6
                ;.cerror init_text_begin!=update_acccon,''
                ; 6 remaining VDU23 bytes above
                .byte 32
                .byte 1
                .byte 0
                .byte 23
vdu19_begin:
music1:
                and counter
                rts
                .cerror *-vdu19_begin!=3,''
                ; 3 remaining VDU19 bytes above
                .byte 4
                .byte 3
                .byte 19
vdu19_end:
sn_write:
                sta system_via.ora_no_handshake
                stz system_via.orb
                ; 6 remaining VDU 23 bytes above
                inx             ;e8        R12 value = $28 (6-bit reg)
                tsb $1700       ;0c 00 17  23,0,12 - set CRTC R12
                sta $16         ;85 16     22,135 - shadow mode 5
                ora $16         ;05 16     22,5 - non-shadow mode 5
init_text_end:
                ldx #8
                jsr +
                stx system_via.orb
+
                rts

pixel_value: .function colour
right=(colour&2)<<3|(colour&1)<<0
                .endfunction right<<3|right<<2|right<<1|right<<0
                
pixel_table:
                .for i=0,i<8,i+=1
                .if (i&4)!=0
                .byte pixel_value(2) ;yellow
                .elsif (i&2)!=0
                .byte pixel_value(1) ;red
                .elsif (i&1)!=0
                .byte pixel_value(3) ;blue
                .else
                .byte pixel_value(0) ;black
                .endif
                .endfor

fill_start:
num_fill_bytes=256-(types_end-fill_end)-(*-start)
                .fill num_fill_bytes
fill_end:
                .cwarn num_fill_bytes!=0,format("spare bytes: %d ($%x)",num_fill_bytes,num_fill_bytes)
                
type_code_size=6
                
type_codes:                
type2: .block
                ; dots scroll north
                adc yc
                and saddr+0
                asl a
                rts
                .endblock
                .cerror size(type2)!=type_code_size,''

type4: .block
                ; chequerboard scroll east
                sbc saddr+0
                eor yc
                rts
                .byte 3         ;palette value - colour 0 = blue
                .endblock
                .cerror size(type4)!=type_code_size,''
type0: .block
                ; dots scroll west
                adc saddr+0
                and yc
                asl a
                rts
                .endblock
                .cerror size(type0)!=type_code_size,''
               
type1: .block
                ; slash scroll east
                sbc saddr+0
                sec
                sbc yc
                rts
                .endblock
                .cerror size(type1)!=type_code_size,''

type3: .block
                ; backslash scroll west
                adc saddr+0
                sec
                sbc yc
                rts
                .endblock
                .cerror size(type3)!=type_code_size,''
types_end:
                .endsection