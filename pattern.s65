                .include "submodules/beeb/include/beeb.s65"
                .cpu '65c02'

;-------------------------------------------------------------------------

*=$70
                .dsection zp
*=$1900
                .dsection code

;-------------------------------------------------------------------------

                .section zp
addr:
                .fill 2
; xc:
;                 .fill 1
yc:
                .fill 1
counter:
                .fill 1
pixel:
                .fill 1
temp:
                .fill 1
temp_counter:
                .fill 1
                .endsection

;-------------------------------------------------------------------------

                .section code
start:
                lda #22
                jsr oswrch
                lda #12         ;i.e., mode 4
                jsr oswrch

                sei
                stz $fe20

                sta $fe00
                lda #$28        ;$7c00
                sta $fe01

                ; set some random frequency on tone 3
                lda #%10000000
                jsr sn_write

                lda #%00111111
                jsr sn_write

                lda #1
                sta $fe00
                ldy #32
                sty $fe01

                sta acccon      ;D=1 - display shadow, map main RAM

                clc
                dec a
                tay
set_palette_loop:
                sta $fe21
                adc #$11
                bcc set_palette_loop

                lda #$80
                jsr sn_write    ;tone 3, freq low bits (and latch register)

                ; doesn't matter what the initial values of addr or
                ; counter are, though the writing will start at an
                ; arbitrary position on screen and the counter may or
                ; may not increment first time round...
fix_addr_msb:
                inc addr+1
                bpl got_addr_msb

                ; TODO - could use top 6 bits of address instead?

                lda counter
                inc counter
                eor counter
                and #32
                beq swap_buffers

                ; next frame...
                ldx #layer0-start
                jsr change

                ldx #layer1-start
                jsr change

                ldx #layer2-start
                jsr change

swap_buffers:
                lda acccon
                eor #acccon.d|acccon.x
                sta acccon

got_addr_msb:
                lda addr+1
                and #%00000011
                ora #$7c
                sta addr+1
loop:
                
                lda addr+1
                sta yc
                lda addr+0

                ; addr high nybble is always 7 (%0111)
                asl a
                rol yc          ;C=0
                asl a
                rol yc          ;C=1
                asl a
                rol yc          ;C=1

                lda counter
layer0:
                jsr type_codes+0*type_code_size
                and #4
                sta temp

                lda counter
                lsr a
                pha
                sec
layer1:
                jsr type_codes+1*type_code_size
                and #8
                ora temp
                lsr a
                sta temp

                pla
                lsr a
                sec
layer2:
                jsr type_codes+2*type_code_size
                and #8
                ora temp

                lsr a
                tax

                asl a
                eor #$0f
                and counter
                and #$0f
                ora #%10010000  ;tone 3 attenuation
                jsr sn_write
                
                lda pixel_table,x
                
                sta (addr)

next_byte:
                inc addr+0
                beq fix_addr_msb

                bra loop

change:
                clc
                lda start+1,x   ;code LSB
                adc #type_code_size
                bcc +
                lda #type_codes-start
+
                sta start+1,x
                rts

sn_write:
                sta system_via.ora_no_handshake
                stz system_via.orb
                jsr +
                ldy #8
                sty system_via.orb
+
                rts

; 0000abcd
; 0a0b0c0d
                
pixel_value: .function colour
right=(colour&8)<<3|(colour&4)<<2|(colour&2)<<1|(colour&1)<<0
                .endfunction (right<<1|right<<0)^$ff
                
pixel_table:
                .for i=0,i<8,i+=1
                .if (i&4)!=0
                .byte pixel_value(2)
                .elsif (i&2)!=0
                .byte pixel_value(1)
                .elsif (i&1)!=0
                .byte pixel_value(4)
                .else
                .byte pixel_value(0)
                .endif
                .endfor
                
                .fill 256-(types_end-type_codes)-(*-start)

type_code_size=6

type_codes:                
type0: .block
                ; dots scroll west
                adc addr+0
                and yc
                asl a
                rts
                .endblock
                .cerror size(type0)!=type_code_size,''
               
type1: .block
                ; slash scroll east
                sbc addr+0
                sec
                sbc yc
                rts
                .endblock
                .cerror size(type1)!=type_code_size,''

type2: .block
                ; grid scroll north
                adc yc
                ora addr+0
                asl a
                rts
                .endblock
                .cerror size(type2)!=type_code_size,''

type3: .block
                ; backslash scroll west
                adc addr+0
                sec
                sbc yc
                rts
                .endblock
                .cerror size(type3)!=type_code_size,''

                ; this one must be the last one. it's 1 byte shorter.
type4: .block
                ; chequerboard scroll east
                sbc addr+0
                eor yc
                rts
                .endblock
                .cerror size(type4)!=type_code_size-1,''

types_end:
                .endsection