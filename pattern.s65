                .include "submodules/beeb/include/beeb.s65"
                .cpu '65c02'

;-------------------------------------------------------------------------

double_buffer=true
                
; doesn't actually seem to work :(
vsync=false
                
;-------------------------------------------------------------------------

*=$70
                .dsection zp
*=$1900
                .dsection code

;-------------------------------------------------------------------------

                .section zp
addr:
                .fill 2
; xc:
;                 .fill 1
yc:
                .fill 1
counter:
                .fill 1
pixel:
                .fill 1
temp:
                .fill 1
                .endsection

;-------------------------------------------------------------------------

                .section code
                lda #22
                jsr oswrch
                lda #12         ;i.e., mode 4
                jsr oswrch

                sei
                stz $fe20

                sta $fe00
                lda #$28        ;$7c00
                sta $fe01
                lda #1
                sta $fe00
                ldy #32
                sty $fe01

                .if double_buffer
                lda #acccon.d
                sta acccon
                .endif

                clc
                dec a
                tay
set_palette_loop:
                sta $fe21
                adc #$11
                bcc set_palette_loop

                ; doesn't matter what the initial values of addr or
                ; counter are, though the writing will start at an
                ; arbitrary position on screen and the counter may or
                ; may not increment first time round...
fix_addr_msb:
                lda addr+1
                inc a
                bpl +
                
                inc counter

                .if double_buffer||vsync
                pha
                .endif

                .if vsync
                lda #2
wait_for_vsync_loop:
                bit system_via.ifr
                beq wait_for_vsync_loop
                sta system_via.ifr
                .endif

                .if double_buffer
                lda acccon
                eor #acccon.d|acccon.x
                sta acccon
                .endif

                .if double_buffer||vsync
                pla
                .endif

+
                and #%00000011
                ora #$7c
                sta addr+1
loop:
                
                lda addr+1
                sta yc
                lda addr+0
                ;sta xc

                asl a
                rol yc
                asl a
                rol yc
                asl a
                rol yc

                ; C=1 at this point - addr high nybble is always 7

                lda counter
                pha
                adc addr+0      ;X coord
                eor yc
                and #4
                sta temp

                pla
                asl a
                pha
                adc addr+0      ;X coord
                eor yc
                and #8
                ora temp
                sta temp

                pla
                asl a
                adc addr+0      ;X coord
                eor yc
                and #16
                ora temp

                lsr a
                lsr a
                tax
                lda pixel_table,x
                
                sta (addr)

                inc addr+0
                beq fix_addr_msb
                bra loop

; 0000abcd
; 0a0b0c0d
                
pixel_value: .function colour
right=(colour&8)<<3|(colour&4)<<2|(colour&2)<<1|(colour&1)<<0
                .endfunction (right<<1|right<<0)^$ff
                
pixel_table:
                .for i=0,i<8,i+=1
                .if (i&4)!=0
                .byte pixel_value(7)
                .elsif (i&2)!=0
                .byte pixel_value(2)
                .elsif (i&1)!=0
                .byte pixel_value(1)
                .else
                .byte pixel_value(0)
                .endif
                .endfor
                .endsection