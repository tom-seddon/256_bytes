                .include "submodules/beeb/include/beeb.s65"
                
*=$70
                .dsection zp
                
*=$1900
                .dsection code
                ;.cerror *>$1a00,"overflow"
                ;.fill $1a00-*,0
                
                .section zp
                .send zp

                .section code

start:
                lda #22
                jsr oswrch

                lda #2
                jsr oswrch

                ldx #$08
                ldy #$f0  ;cursor off, display off
                jsr read_write_crtc

                jsr init
                jsr init

                sei
                txs

                ; this puts the cursor back on. But... VDU5! So the
                ; cursor is hidden anyway.
                ldx #8
                jsr read_write_crtc

main_loop:
                tsx
                txa
                and #$0f
                pha             ;save counter&15
                ora #%11110000  ;noise attenuation
                jsr sn_write

                pla             ;restore counter&15
                clc
                adc #8
                and #$0f
                pha             ;save 4-bit tone attenuation 
                ora #%11010000  ;tone 3 attenuation
                jsr sn_write

                pla             ;restore 4-bit tone attenuation 
                ora #%10110000  ;tone 2 attenuation
                jsr sn_write

                lda #%11001111  ;tone 3 freq
                jsr sn_write

                tsx
                txa
                lsr a
                pha             ;save counter>>1
                lsr a
                lsr a
                lsr a
                and #7
                tax
                lda music,x
                pha             ;save music byte
                jsr sn_write

                lda #%10101111  ;tone 2 freq
                jsr sn_write

                pla             ;restore music byte
                asl a           ;lower by 1 octave
                jsr sn_write

                pla             ;restore counter>>1
                and #3
                ora #%11100100  ;white noise
                jsr sn_write

                ldx #13
                jsr read_write_crtc
                adc #80
                sta $fe01

                dex
                jsr read_write_crtc
                adc #0
                cmp #$10
                bcc +
                lda #$06
+
                sta $fe01

                pla             ;increment counter

                lda #2
-
                bit system_via.ifr
                beq -
                sta system_via.ifr

                ldx #19
x_loop:
                ldy #128
y_loop:
                lda system_via.t1c_h
                ora #$70
                sta video_ula_palette

                dey
                bne y_loop

                dex
                bne x_loop

                beq main_loop
                
read_write_crtc:
                stx $fe00
                lda $fe01
                sty $fe01
                rts

sn_write:
                ldx #$ff
                stx system_via.ddra
                sta system_via.ora_no_handshake
                inx
                stx system_via.orb
                lda system_via.irb
                ora #$08
                sta system_via.orb
                rts

init:
                ldx #16
init_loop:
                lda xs-1,x
                ;and #%11111000 ;no need! It's the pixel fraction!
                sta text.x+1

                and #%00000111
                sta text.x+0

                ldy #text.message-text
-
                lda text-1,y
                jsr oswrch
                dey
                bne -

                dex
                bne init_loop

                rts                
                
music:
                .byte 22        ;F
                .byte 25        ;Eb
                .byte 27        ;D
                .byte 25        ;Eb
                .byte 27        ;D
                .byte 25        ;Eb
                .byte 27        ;D
                .byte 30        ;C
                
message_text="BITSHIFTERS"
initial_x=1280
initial_y=1023
                
xs:
                .for i:=0,i<16,i+=1
value:=80-int(len(message_text)/2.0*8+sin(i/15.0*2.0*pi)*4)
                ; Mode 2 scale - 8 graphics units per pixel
                .byte (value&%00011111)<<3|(value&%11100000)>>5
                .next

text: .block
                .text message_text[::-1]
y:
                .byte >initial_y
                .byte <initial_y
x:
                ; Gets printed when the init text is printed! - so
                ; initial value must put the output somewhere off
                ; screen.
                .byte >initial_x
                .byte <initial_x
                
                .text 4,25      ;PLOT4 = MOVE
                .text 5,11,4
message:
                .bend

                .send code
                