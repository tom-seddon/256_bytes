                .include "submodules/beeb/include/beeb.s65"
                .cpu '65c02'

;-------------------------------------------------------------------------

sn_freq_reg: .function ch
                .cerror ch<0||ch>3,"invalid SN channel"
                .endfunction $80|ch<<5

sn_atten_reg: .function ch
                .cerror ch<0||ch>3,"invalid SN channel"
                .endfunction $80|ch<<5|$10
                
sn_atten: .function ch,atten
                .cerror ch<0||ch>3,"invalid SN channel"
                .cerror atten<0||atten>15,"invalid SN attenuation"
                .endfunction sn_atten_reg(ch)|atten

sn_freqh: .function freq
                .cerror freq<0||freq>1023,"invalid SN frequency"
                .endfunction freq>>4

sn_freql: .function ch,freq
                .cerror freq<0||freq>1023,"invalid SN frequency"
                .endfunction sn_freq_reg(ch)|freq&15

colour_from_brightness_index: .function index
                .cerror index<0||index>7,"invalid colour index"
                .endfunction (index&1)<<2|(index&2)>>1|(index&4)>>1
                
mode2_left_value: .function colour_
                .cerror colour_<0||colour_>15,"invalid mode 2 colour"
                .endfunction (colour_&8)<<4|(colour_&4)<<3|(colour_&2)<<2|(colour_&1)<<1

mode2_value: .function left_,right_
                .endfunction mode2_left_value(left_)|mode2_left_value(right_)>>1

;-------------------------------------------------------------------------

*=0
                .dsection code
zp_start:
                .dsection zp

; DMAX_COLOUR_CHANGE_COUNTER_VALUE=7
; MIN_MAX_COLOUR=16
; MAX_MAX_COLOUR=24
                
;-------------------------------------------------------------------------

                .section zp
                .endsection

;-------------------------------------------------------------------------

                .section code
start:
                ldx #$fd
init_loop:
                lda init+3,x
                ; the initial value of fx isn't important. Might as
                ; well use the $ff of $ffee.
fx:=*+2
                jsr oswrch
                sei
                stx system_via.ddra
dest:
                inx             ;$e8
                bmi init_loop   ;$30

main_loop:
                lda #2
wait_for_vblank_loop:
ifr_ptr=*+1
                bit system_via.ifr
                beq wait_for_vblank_loop
                sta (ifr_ptr)

                ldx #31

fill_column_loop:
                ldy #7

                txa
                and fx
                bne got_colour

                lda fx
                and #7
                tay

got_colour:
                lda pixels,y
                
                ldy #7
fill_char_loop:
                sta (dest),y
                dey
                bpl fill_char_loop

                lda #$80
                cpx #0
                bne +
                lda #$78
+
                clc
                adc dest+0
                sta dest+0
                sta crtc_addr_lsb

                lda #$02
                tay             ;Y=2
                adc dest+1
                bpl dest_updated
                ; C=0
                sbc #$4f
dest_updated:
                sta dest+1
                
                dex
                bpl fill_column_loop

                eor fx
                rol a
                ; and #%10111111  ;no noise
                sta system_via.ora_no_handshake
                
orb_ptr=*+1
                stz system_via.orb

pixels:                
                .byte $3f       ;7,7 = 1-byte NOP = nop +1 1
                .byte $3c       ;6,6 = 1-byte NOP = nop +1 2
                .byte $0f       ;3,3 = BIT abs,x  = BIT $330c,x +4 6
                .byte $0c       ;2,2 = TSB abs    = -
                .byte $33       ;5,5 = 1-byte NOP = -
                .byte $03       ;1,1 = 1-byte NOP = nop +1 7
                .byte $30       ;4,4 = BMI        = bmi +2/+3 9/10
                .byte $00       ;0,0 = BRK        = -

                lda #8
                sta (orb_ptr)
                
                dec fx

                ; Y=2
                lda dest+1
div8_loop:
                lsr a
                ror crtc_addr_lsb
                dey
                bpl div8_loop

                ; Y=$ff
                ldx #12
set_crtc_addr_loop:
                stx $fe00
                sta $fe01
crtc_addr_lsb=*+1
                lda #$ff
                inx
                iny
                beq set_crtc_addr_loop

                bra main_loop

; sn_write:
;                 sta system_via.ora_no_handshake

; orb_ptr:=*+1
;                 stz system_via.orb

                ; ldx #8          ;+2 11
                ; stx system_via.orb ;+4 15
                ; rts
                
init:
                .byte 22,2,5
                .endsection