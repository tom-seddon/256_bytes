                .include "submodules/beeb/include/beeb.s65"
                .cpu '65c02'

;-------------------------------------------------------------------------

sn_freq_reg: .function ch
                .cerror ch<0||ch>3,"invalid SN channel"
                .endfunction $80|ch<<5

sn_atten_reg: .function ch
                .cerror ch<0||ch>3,"invalid SN channel"
                .endfunction $80|ch<<5|$10
                
sn_atten: .function ch,atten
                .cerror ch<0||ch>3,"invalid SN channel"
                .cerror atten<0||atten>15,"invalid SN attenuation"
                .endfunction sn_atten_reg(ch)|atten

sn_freqh: .function freq
                .cerror freq<0||freq>1023,"invalid SN frequency"
                .endfunction freq>>4

sn_freql: .function ch,freq
                .cerror freq<0||freq>1023,"invalid SN frequency"
                .endfunction sn_freq_reg(ch)|freq&15

colour_from_brightness_index: .function index
                .cerror index<0||index>7,"invalid colour index"
                .endfunction (index&1)<<2|(index&2)>>1|(index&4)>>1
                
mode2_left_value: .function colour_
                .cerror colour_<0||colour_>15,"invalid mode 2 colour"
                .endfunction (colour_&8)<<4|(colour_&4)<<3|(colour_&2)<<2|(colour_&1)<<1

mode2_value: .function left_,right_
                .endfunction mode2_left_value(left_)|mode2_left_value(right_)>>1

;-------------------------------------------------------------------------

*=$00
                .dsection zp
*=$1900
                .dsection code

; DMAX_COLOUR_CHANGE_COUNTER_VALUE=7
; MIN_MAX_COLOUR=16
; MAX_MAX_COLOUR=24
                
;-------------------------------------------------------------------------

                .section zp
dest: .fill 2
crtc_addr_lsb: .fill 1
fx: .fill 1
fy: .fill 2
counter: .fill 1
                .endsection

;-------------------------------------------------------------------------

                .section code
start:
                
                ldx #init_end-init
init_loop:
                lda init,x
                jsr oswrch
                dex
                bpl init_loop

                sta $ffff
                
                sei

                ; stx system_via.ddra

clear_zp_loop:
                inx
                stz 0,x
                bpl clear_zp_loop

                ; "dec dest+1"?
                lda #$7b
                sta dest+1

main_loop:
                ; jsr osrdch

                lda #2
wait_for_vblank_loop:
                bit system_via.ifr
                beq wait_for_vblank_loop
                sta system_via.ifr

                lda #79
                sta fx

fill_row_loop:
                jsr fun

                and #7
                tax
                lda pixels,x

                ldy #1
fill_char_loop:
                sta (dest),y
                dey
                bpl fill_char_loop

                clc
                lda dest+0
                adc #8 
                sta dest+0
                sta crtc_addr_lsb

                lda dest+1
                adc #$00
                bpl dest_updated
                lda #$30
dest_updated:
                sta dest+1
                
                dec fx
                bpl fill_row_loop

                inc fy+0
                bne fy_updated
                inc fy+1
fy_updated:

;                 clc
;                 adc #$0a        ;+2560
;                 bpl +
;                 sbc #$4f
; +
                
                ; lda dest+1
                ldy #3
div8_loop:
                lsr a
                ror crtc_addr_lsb
                dey
                bne div8_loop

                ldx #12
                stx $fe00
                sta $fe01
                inx
                stx $fe00
                lda crtc_addr_lsb
                sta $fe01

                
halt:
                lda fy
                cmp #7
                beq halt
                
                jmp main_loop

fun: .proc
                lda fy
                and fx
                bne +
                lda #fy+0
+
                rts
                .endproc
                
pixels:
                .byte mode2_value(0,0)
                .byte mode2_value(4,4)
                .byte mode2_value(1,1)
                .byte mode2_value(5,5)
                .byte mode2_value(2,2)
                .byte mode2_value(6,6)
                .byte mode2_value(3,3)
                .byte mode2_value(7,7)

init:
                .byte 5
                .byte 2,22
init_end:
                .endsection